# 3장 빅 오 표기법



### **Big O Notation**

**알고리즘이 얼마나 빠른지 표시하는 방법**

- 입력 데이터 크기가 증가할 때 알고리즘 연산 시간의 증가 방식
- O(n)   *→ 여기서 n은 연산횟수*
- 알고리즘에 얼마나 많은 단계가 필요한지를 알고리즘이 처리할 데이터 원소 수에 따라 표현



|O(1)|O(N)|
|:-|:-|
|1. 데이터의 크기에 **상관없이** 알고리즘에 필요한 **단계 수가 일정함**|1. **N개의 원소**가 있을 때 알고리즘을 끝내는데 **N개의 단계**가 필요하다는 표현|
|2. 필요한 단계 수 : 한 단계|2. 필요한 단계 수 : 배열의 원소 개수만큼 |
|3. Ex). 배열의 읽기, 배열 끝에 삽입과 삭제|3. Ex). 선형 검색|

    
<br>    
   

## 상수시간과 선형시간


### 1️⃣ O(1) 알고리즘

→ **상수 시간(constant time)** 의 시간 복잡도

→ O(1) 알고리즘은 처리할 데이터가 **증가해도** 단계 수는 **증가하지 않음**

→ 어떤 O(N) 알고리즘 보다도 효율적

<br>

### 2️⃣ O(N) 알고리즘

→ **선형 시간(linear time)** 의 시간 복잡도를 가지고 있음

→ 처리할 데이터가 **하나 증가**하면 O(N) 알고리즘은 **한 단계 증가**

<br>

### 3️⃣ O(logN) 알고리즘

→ **로그 시간(log time)** 의 시간 복잡도

→ 데이터가 **두 배 증가**할 때마다 **한 단계씩** 늘어나는 알고리즘을 표현

→ **O(1)** 보다는 덜 효율적이면서 **O(N)** 보다는 훨씬 효율적

→ Ex) 이진 검색

<br>

#### 🤷‍♀️ 왜 O(1)알고리즘이 O(N)알고리즘보다 항상 효율적일까?

**O(N)알고리즘**이 **O(1)알고리즘**보다 덜 효율적인 지점에 반드시 다다르게 되기 때문


교차지점을 넘어서게 되면 항상 **O(N)** 이 **O(1)** 보다 시간이 더 걸리게 되기 때문

<br>

#### 🤷‍♀️ 같은 알고리즘, 다른 시나리오

**선형 검색**
   1. 최선의 시나리오 : O(1)
    2. 최악의 시나리오 : O(N)

    ⇒ 빅 오 노테이션은 일반적으로 최악의 시나리오를 표현함

    그래야 최악에도 이 정도의 성능을 나타냄을 알 수 있기 때문
    

<br>

#### 🌼 **효율성 : O(1) > O(logN) > O(N) 🌼**

<br>





## O(logN) 해석

**O(log2N)의 줄임말**

- O(N) : 데이터 원소가 N개 있으면 → 알고리즘에서 N단계가 소요
- O(logN) : 데이터 원소가 N개 있으면 → 알고리즘에서 logN단계가 소요

Ex) 이진 검색

- 특정 항목을 찾을 때 찾는 값에 도달할 때가지 배열의 셀을 계속해서 반으로 나누며 범위를 좁혀 나감
- 원소가 하나가 될 때가지 데이터 원소를 계속해서 반으로 줄이는 만큼의 단계 수가 걸림


